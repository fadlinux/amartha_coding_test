// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package payment

import (
	"context"
	mPayment "github.com/fadlinux/amartha_coding_test/internal/model/payment"
	"sync"
)

// Ensure, that UsecaseMock does implement Usecase.
// If this is not the case, regenerate this file with moq.
var _ Usecase = &UsecaseMock{}

// UsecaseMock is a mock implementation of Usecase.
//
//	func TestSomethingThatUsesUsecase(t *testing.T) {
//
//		// make and configure a mocked Usecase
//		mockedUsecase := &UsecaseMock{
//			AddPaymentFunc: func(ctx context.Context, request mPayment.AddPaymentRequest) (int64, error) {
//				panic("mock out the AddPayment method")
//			},
//			GetIdFunc: func(ctx context.Context, paymentId int64) ([]mPayment.AddPaymentRequest, error) {
//				panic("mock out the GetId method")
//			},
//			GetSumTotalFunc: func(ctx context.Context, loanId int64) (int64, error) {
//				panic("mock out the GetSumTotal method")
//			},
//		}
//
//		// use mockedUsecase in code that requires Usecase
//		// and then make assertions.
//
//	}
type UsecaseMock struct {
	// AddPaymentFunc mocks the AddPayment method.
	AddPaymentFunc func(ctx context.Context, request mPayment.AddPaymentRequest) (int64, error)

	// GetIdFunc mocks the GetId method.
	GetIdFunc func(ctx context.Context, paymentId int64) ([]mPayment.AddPaymentRequest, error)

	// GetSumTotalFunc mocks the GetSumTotal method.
	GetSumTotalFunc func(ctx context.Context, loanId int64) (int64, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddPayment holds details about calls to the AddPayment method.
		AddPayment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Request is the request argument value.
			Request mPayment.AddPaymentRequest
		}
		// GetId holds details about calls to the GetId method.
		GetId []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PaymentId is the paymentId argument value.
			PaymentId int64
		}
		// GetSumTotal holds details about calls to the GetSumTotal method.
		GetSumTotal []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LoanId is the loanId argument value.
			LoanId int64
		}
	}
	lockAddPayment  sync.RWMutex
	lockGetId       sync.RWMutex
	lockGetSumTotal sync.RWMutex
}

// AddPayment calls AddPaymentFunc.
func (mock *UsecaseMock) AddPayment(ctx context.Context, request mPayment.AddPaymentRequest) (int64, error) {
	if mock.AddPaymentFunc == nil {
		panic("UsecaseMock.AddPaymentFunc: method is nil but Usecase.AddPayment was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Request mPayment.AddPaymentRequest
	}{
		Ctx:     ctx,
		Request: request,
	}
	mock.lockAddPayment.Lock()
	mock.calls.AddPayment = append(mock.calls.AddPayment, callInfo)
	mock.lockAddPayment.Unlock()
	return mock.AddPaymentFunc(ctx, request)
}

// AddPaymentCalls gets all the calls that were made to AddPayment.
// Check the length with:
//
//	len(mockedUsecase.AddPaymentCalls())
func (mock *UsecaseMock) AddPaymentCalls() []struct {
	Ctx     context.Context
	Request mPayment.AddPaymentRequest
} {
	var calls []struct {
		Ctx     context.Context
		Request mPayment.AddPaymentRequest
	}
	mock.lockAddPayment.RLock()
	calls = mock.calls.AddPayment
	mock.lockAddPayment.RUnlock()
	return calls
}

// GetId calls GetIdFunc.
func (mock *UsecaseMock) GetId(ctx context.Context, paymentId int64) ([]mPayment.AddPaymentRequest, error) {
	if mock.GetIdFunc == nil {
		panic("UsecaseMock.GetIdFunc: method is nil but Usecase.GetId was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		PaymentId int64
	}{
		Ctx:       ctx,
		PaymentId: paymentId,
	}
	mock.lockGetId.Lock()
	mock.calls.GetId = append(mock.calls.GetId, callInfo)
	mock.lockGetId.Unlock()
	return mock.GetIdFunc(ctx, paymentId)
}

// GetIdCalls gets all the calls that were made to GetId.
// Check the length with:
//
//	len(mockedUsecase.GetIdCalls())
func (mock *UsecaseMock) GetIdCalls() []struct {
	Ctx       context.Context
	PaymentId int64
} {
	var calls []struct {
		Ctx       context.Context
		PaymentId int64
	}
	mock.lockGetId.RLock()
	calls = mock.calls.GetId
	mock.lockGetId.RUnlock()
	return calls
}

// GetSumTotal calls GetSumTotalFunc.
func (mock *UsecaseMock) GetSumTotal(ctx context.Context, loanId int64) (int64, error) {
	if mock.GetSumTotalFunc == nil {
		panic("UsecaseMock.GetSumTotalFunc: method is nil but Usecase.GetSumTotal was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		LoanId int64
	}{
		Ctx:    ctx,
		LoanId: loanId,
	}
	mock.lockGetSumTotal.Lock()
	mock.calls.GetSumTotal = append(mock.calls.GetSumTotal, callInfo)
	mock.lockGetSumTotal.Unlock()
	return mock.GetSumTotalFunc(ctx, loanId)
}

// GetSumTotalCalls gets all the calls that were made to GetSumTotal.
// Check the length with:
//
//	len(mockedUsecase.GetSumTotalCalls())
func (mock *UsecaseMock) GetSumTotalCalls() []struct {
	Ctx    context.Context
	LoanId int64
} {
	var calls []struct {
		Ctx    context.Context
		LoanId int64
	}
	mock.lockGetSumTotal.RLock()
	calls = mock.calls.GetSumTotal
	mock.lockGetSumTotal.RUnlock()
	return calls
}
